<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validador JSON</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
        rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Azeret+Mono:ital,wght@0,100..900;1,100..900&family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap"
        rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&family=Fira+Sans+Condensed:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Inconsolata:wght@200..900&family=Noto+Sans+Mono:wght@100..900&family=Source+Code+Pro:ital,wght@0,600;1,600&display=swap" rel="stylesheet">
    <!-- TODO delete -index.css- file. -->
    <link href="static/indexApp.css" type="text/css" rel="stylesheet">
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>Validador de Controles Volum√©tricos</h1>
            <p class="subtitle">Valida el cumplimiento de tu <i><b>reporte mensual</b></i></p>
            <button id="themeToggle" class="theme-toggle" aria-label="Cambiar tema">
                <span class="theme-icon">üåô</span>
            </button>
        </div>

        <div class="upload-section">
            <div class="upload-card" id="uploadCard">
                <input type="file" id="jsonFile" class="file-input" accept=".json">
                <div class="upload-icon">üìé</div>
                <div class="upload-title">Selecciona tu archivo JSON</div>
                <div class="upload-description">o arrastra y suelta aqu√≠</div>
                <div class="file-name-display" id="fileNameDisplay" style="display: none;"></div>
            </div>
        </div>

        <div class="content-wrapper" id="contentWrapper" style="display: none;">
            <!-- JSON Section -->
            <div class="section">
                <div class="section-header">
                    <div class="section-title">
                        <span class="section-icon">üìÑ</span>
                        <span id="jsonFileName">Contenido del archivo</span>
                    </div>
                    <button class="copy-btn" id="copyBtn">
                        üìã Copiar
                    </button>
                </div>
                <div class="section-content">
                    <div class="json-viewer-wrapper">
                        <div class="json-viewer" id="jsonContent"></div>
                    </div>
                </div>
            </div>

            <!-- Results Section -->
            <div class="section">
                <div class="section-header">
                    <!-- <div class="section-title">
                        <span class="section-icon">üîç</span>
                        Resultados de validaci√≥n
                    </div> -->
                    <span class="section-badge" id="statusBadge">Validando...</span>
                </div>
                <div class="section-content">
                    <div id="resultsContent"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast">
        <div class="toast-icon">‚úì</div>
        JSON copiado correctamente
    </div>

    <script>
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;

        const savedTheme = localStorage.getItem('theme') || 'dark';
        html.setAttribute('data-theme', savedTheme);
        updateThemeIcon(savedTheme);

        themeToggle.addEventListener('click', () => {
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
        });

        function updateThemeIcon(theme) {
            const icon = themeToggle.querySelector('.theme-icon');
            icon.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }

        let currentJSON = null;
        const uploadCard = document.getElementById('uploadCard');
        const fileInput = document.getElementById('jsonFile');
        const fileNameDisplay = document.getElementById('fileNameDisplay');

        // Upload interactions
        uploadCard.addEventListener('click', () => fileInput.click());

        uploadCard.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadCard.classList.add('dragover');
        });

        uploadCard.addEventListener('dragleave', () => {
            uploadCard.classList.remove('dragover');
        });

        uploadCard.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadCard.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type === 'application/json') {
                handleFile(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFile(file);
        });

        async function handleFile(file) {
            // Show file name
            fileNameDisplay.textContent = `üìÑ ${file.name}`;
            fileNameDisplay.style.display = 'inline-block';
            
            try {
                const text = await file.text();
                const texT = text
                    .replace(/:\s*NaN\s*([,\}])/g, ': "NaN"$1')
                    .replace(/:\s*Infinity\s*([,\}])/g, ': "Infinity"$1')
                    .replace(/:\s*-Infinity\s*([,\}])/g, ': "-Infinity"$1')
                    .replace(/:\s*undefined\s*([,\}])/g, ': "undefined"$1');

                currentJSON = JSON.parse(texT)

                document.getElementById('jsonFileName').textContent = file.name;
                displayJSON(currentJSON);
                document.getElementById('contentWrapper').style.display = 'flex';

                // API call
                let formData = new FormData();
                formData.append("file", file);

                let response = await fetch("/upload/", {
                    method: "POST",
                    body: formData
                });
                let result = await response.json();

                // Manejar diferentes tipos de respuesta
                let errors = [];
                if (Array.isArray(result)) {
                    errors = result;
                } else if (result && Array.isArray(result.errors)) {
                    errors = result.errors;
                } else if (result && result.error) {
                    errors = [{ type_error: 'Error', error: result.error }];
                }

                displayResults(errors);

            } catch (error) {
                console.error('Error:', error);
                displayError(error.message);
            }
        }

        const INVALID_VALUE_REPLACEMENT = "Valor NaN no valido";
        let nanValuesCount = 0;

        function sanitizeRawJsonString(jsonString) {
            return jsonString
                .replace(/:\s*NaN/g, `: "${INVALID_VALUE_REPLACEMENT}"`)
                .replace(/:\s*Infinity/g, `: "${INVALID_VALUE_REPLACEMENT}"`)
                .replace(/:\s*-Infinity/g, `: "${INVALID_VALUE_REPLACEMENT}"`)
                .replace(/:\s*undefined/g, `: "${INVALID_VALUE_REPLACEMENT}"`)
                .replace(/"\s*NaN\s*"/g, `"${INVALID_VALUE_REPLACEMENT}"`)
                .replace(/"\s*Infinity\s*"/g, `"${INVALID_VALUE_REPLACEMENT}"`)
                .replace(/"\s*-Infinity\s*"/g, `"${INVALID_VALUE_REPLACEMENT}"`);
        }

        function countNanValuesInString(jsonString) {
            const nanMatches = [
                ...jsonString.matchAll(/:\s*NaN/g),
                ...jsonString.matchAll(/:\s*Infinity/g),
                ...jsonString.matchAll(/:\s*-Infinity/g),
                ...jsonString.matchAll(/:\s*undefined/g),
                ...jsonString.matchAll(/"\s*NaN\s*"/g),
                ...jsonString.matchAll(/"\s*Infinity\s*"/g),
                ...jsonString.matchAll(/"\s*-Infinity\s*"/g)
            ];
            return nanMatches.length;
        }

        function displayJSON(json) {
            let formatted = JSON.stringify(json, null, 2);

            // Contar valores NaN antes de sanitizar
            nanValuesCount = countNanValuesInString(formatted);

            // Sanitizar el JSON
            if (nanValuesCount > 0) {
                formatted = sanitizeRawJsonString(formatted);
            }

            const highlighted = syntaxHighlight(formatted);
            document.getElementById('jsonContent').innerHTML = highlighted;

            // Actualizar el badge si hay sanitizaci√≥n
            if (nanValuesCount > 0) {
                const statusBadge = document.getElementById('statusBadge');
                const originalText = statusBadge.textContent;
                statusBadge.innerHTML = `
                    <span style="margin-right: 8px;"> ${nanValuesCount} valor${nanValuesCount > 1 ? 'es' : ''} sanitizado${nanValuesCount > 1 ? 's' : ''}</span>
                `;
                statusBadge.style.background = 'rgba(251, 191, 36, 0.2)';
                statusBadge.style.color = '#fbbf24';
            }
        }

        function syntaxHighlight(json) {
            json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            const colors = ['#FF6188', '#FC9867', '#FFD866', '#A9DC76', '#78DCE8', '#AB9DF2'];

            let colorStack = [];
            let depth = 0;

            return json.replace(/("(\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"\n])*"(:)?|\b(true|false|null)\b|\b-?\d+(\.\d+)?([eE][+\-]?\d+)?\b|{|}|\[|\])/g, function (match) {
                let cls = 'hljs-number';

                // Si es una llave de apertura ( { o [ )
                if (match === '{' || match === '[') {
                    cls = 'hljs-brace';
                    // Determinar el color basado en la profundidad
                    let color = colors[depth % colors.length];
                    // A√±adir el color a la pila
                    colorStack.push(color);
                    // Aumentamos la profundidad
                    depth++;
                    return `<span class="${cls}" style="color: ${color};">${match}</span>`;
                }

                // Si es una llave de cierre ( } o ] )
                if (match === '}' || match === ']') {
                    cls = 'hljs-brace';
                    // Extraer el color de la pila
                    let color = colorStack.pop();
                    // Disminuimos la profundidad
                    depth--;
                    return `<span class="${cls}" style="color: ${color};">${match}</span>`;
                }

                // Si es una clave (entre comillas seguida de :)
                if (/^"/.test(match)) {
                    if (/:$/.test(match)) {
                        cls = 'hljs-keyword'; /* Claves - blanco */
                    } else {
                        cls = 'hljs-string'; /* Strings - amarillo */
                    }
                } else if (/true|false/.test(match)) {
                    cls = 'hljs-literal';
                } else if (/null/.test(match)) {
                    cls = 'hljs-literal';
                } else if (/^-?\d+(\.\d+)?([eE][+\-]?\d+)?$/.test(match)) {
                    cls = 'hljs-number';
                }

                return `<span class="${cls}">${match}</span>`;
            });
        }

        /**
         * Navega hacia un elemento espec√≠fico del JSON basado en un path
         */
        function navigateToJsonElement(sourcePath) {
            if (!sourcePath || !currentJSON) {
                console.warn('No se puede navegar: path o JSON no disponible');
                return;
            }

            try {
                const result = getValueFromPath(currentJSON, sourcePath);

                if (result.value === undefined) {
                    console.warn('No se encontr√≥ el elemento en el path:', sourcePath);
                    showToast('No se pudo localizar el elemento', 'warning');
                    return;
                }
                if (value === sanitizeRawJsonString(value)) {
                    showToast('El valor es NaN o inv√°lido y fue sanitizado', 'warning');
                    return;
                }

                // console.log('Valor encontrado:', result.value);
                // console.log('Bracket path:', result.bracketPath);

                const jsonContent = document.getElementById('jsonContent');
                const found = highlightValueInDOM(jsonContent, result.value, sourcePath, result.bracketPath);

                if (found) {
                    showToast('Elemento localizado', 'success');
                } else {
                    showToast('Elemento inv√°lido, no se pudo resaltar.', 'warning');
                }

            } catch (error) {
                console.error('Error al navegar:', error);
                showToast('Error al localizar elemento', 'error');
            }
        }

        /**
         * Obtiene el valor de un objeto siguiendo un path
         */
        function getValueFromPath(obj, path) {
            const parts = path.split('.').flatMap(part => {
                const matches = part.match(/([^\[]+)|\[(\d+)\]/g);
                return matches ? matches.map(m => m.replace(/[\[\]]/g, '')) : [part];
            });

            let current = obj;
            let splittedPath = path.split('.');
            let bracketPath = "";

            for (let part = 0; part < splittedPath.length; part++) {
                if (splittedPath[part].includes("[")) {
                    let key = splittedPath[part].split("[")[0];
                    let index = parseInt(splittedPath[part].split("[")[1].replace("]", ""));
                    bracketPath += `["${key}"][${index}]`;
                } else {
                    bracketPath += `["${splittedPath[part]}"]`;
                }
            }

            for (const part of parts) {
                if (current === null || current === undefined) {
                    return { value: undefined, bracketPath: bracketPath };
                }

                if (!isNaN(part) && Array.isArray(current)) {
                    current = current[parseInt(part)];
                } else {
                    current = current[part];
                }
            }

            return { value: current, bracketPath: bracketPath };
        }

        /**
         * Resalta un valor espec√≠fico en el DOM del JSON renderizado
         */
        function highlightValueInDOM(container, targetValue, sourcePath, bracketPath) {
            // Limpiar highlights previos
            const previousHighlights = container.querySelectorAll('.json-highlight');
            previousHighlights.forEach(el => el.classList.remove('json-highlight'));

            // console.log('Buscando con bracket path:', bracketPath);

            const allSpans = container.querySelectorAll('span');
            const isObject = typeof targetValue === 'object' && targetValue !== null;

            // Convertir el bracketPath a un patr√≥n de b√∫squeda secuencial
            // ["Producto"][0]["ReporteDeVolumenMensual"]["Recepciones"]...
            const pathPattern = bracketPath.match(/\["([^"]+)"\]|\[(\d+)\]/g);

            if (!pathPattern) {
                console.warn('No se pudo parsear el bracket path');
                return false;
            }

            console.log('Path pattern:', pathPattern);

            let currentPatternIndex = 0;
            let foundSpanIndex = -1;

            for (let i = 0; i < allSpans.length && currentPatternIndex < pathPattern.length; i++) {
                const span = allSpans[i];
                const text = span.textContent.trim();

                const currentPattern = pathPattern[currentPatternIndex];

                // Extraer si es una key ["nombre"] o un √≠ndice [0]
                const keyMatch = currentPattern.match(/\["([^"]+)"\]/);
                const indexMatch = currentPattern.match(/\[(\d+)\]/);

                if (keyMatch) {
                    // Estamos buscando una clave
                    const expectedKey = `"${keyMatch[1]}":`;

                    if (text === expectedKey) {
                        // console.log(`Encontrado "${keyMatch[1]}" en span ${i}`);
                        currentPatternIndex++;

                        // Si este es el √∫ltimo elemento del pattern, guardamos el √≠ndice
                        if (currentPatternIndex === pathPattern.length) {
                            foundSpanIndex = i;
                            break;
                        }
                    }
                } else if (indexMatch && currentPatternIndex > 0) {
                    // El √≠ndice se maneja impl√≠citamente al encontrar la key dentro del array correcto
                    // Solo necesitamos saltar al elemento correcto
                    const targetIndex = parseInt(indexMatch[1]);
                    let arrayItemCount = 0;
                    let braceDepth = 0;
                    let foundArray = false;

                    // Retroceder para encontrar el inicio del array
                    for (let j = i - 1; j >= 0; j--) {
                        const prevText = allSpans[j].textContent.trim();
                        if (prevText === '[') {
                            foundArray = true;
                            // Ahora contar elementos hasta llegar al √≠ndice correcto
                            braceDepth = 1;
                            for (let k = j + 1; k < allSpans.length && arrayItemCount <= targetIndex; k++) {
                                const itemText = allSpans[k].textContent.trim();

                                if (itemText === '{' || itemText === '[') {
                                    if (braceDepth === 1 && arrayItemCount === targetIndex) {
                                        // Este es el elemento que buscamos
                                        i = k - 1; // Ajustamos i para continuar desde aqu√≠
                                        currentPatternIndex++;
                                        break;
                                    }
                                    braceDepth++;
                                } else if (itemText === '}' || itemText === ']') {
                                    braceDepth--;
                                    if (braceDepth === 1) {
                                        arrayItemCount++;
                                    }
                                    if (braceDepth === 0) break;
                                }
                            }
                            break;
                        }
                    }

                    if (currentPatternIndex === pathPattern.length) {
                        foundSpanIndex = i;
                        break;
                    }
                }
            }

            if (foundSpanIndex === -1) {
                console.warn('No se encontr√≥ el elemento en el DOM');
                return false;
            }

            // console.log('Elemento encontrado en span:', foundSpanIndex);

            if (isObject) {
                return highlightObjectBlock(allSpans, foundSpanIndex);
            } else {
                const valueStr = JSON.stringify(targetValue).replace(/^"|"$/g, '');
                return highlightPrimitiveValue(allSpans, foundSpanIndex, valueStr);
            }
        }

        function highlightObjectBlock(allSpans, startIndex) {
            let braceCount = 0;
            let foundOpeningBrace = false;
            let highlightedSpans = [];

            // Buscar la llave de apertura y resaltar todo el bloque
            for (let j = startIndex; j < allSpans.length; j++) {
                const spanText = allSpans[j].textContent.trim();

                // Detectar llave de apertura
                if ((spanText === '{' || spanText === '[') && !foundOpeningBrace) {
                    foundOpeningBrace = true;
                    braceCount = 1;
                    highlightedSpans.push(allSpans[j]);
                    continue;
                }

                if (foundOpeningBrace) {
                    highlightedSpans.push(allSpans[j]);

                    // Contar llaves para encontrar el cierre correspondiente
                    if (spanText === '{' || spanText === '[') {
                        braceCount++;
                    } else if (spanText === '}' || spanText === ']') {
                        braceCount--;

                        // Encontramos el cierre del objeto
                        if (braceCount === 0) {
                            // Aplicar highlight a todos los spans del bloque
                            highlightedSpans.forEach(span => {
                                span.classList.add('json-highlight');
                            });

                            // Scroll al primer elemento (la llave de apertura)
                            highlightedSpans[0].scrollIntoView({
                                behavior: 'smooth',
                                block: 'center'
                            });

                            return true;
                        }
                    }
                }
            }

            return false;
        }

        function highlightPrimitiveValue(allSpans, startIndex, valueStr) {
            for (let j = startIndex + 1; j < Math.min(startIndex + 5, allSpans.length); j++) {
                const valueSpan = allSpans[j];
                const valueText = valueSpan.textContent.trim().replace(/^"|"$/g, '');

                if (valueText === valueStr) {
                    valueSpan.classList.add('json-highlight');
                    valueSpan.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                    return true;
                }
            }

            return false;
        }

        function displayResults(errors) {
            const resultsDiv = document.getElementById('resultsContent');
            const statusBadge = document.getElementById('statusBadge');

            // Asegurar que errors sea un array
            if (!Array.isArray(errors)) {
                console.error('La respuesta no es un array:', errors);
                errors = [];
            }

            if (errors.length === 0) {
                statusBadge.textContent = 'Sin errores';
                statusBadge.style.background = 'rgba(52, 211, 153, 0.2)';
                statusBadge.style.color = '#059669';

                resultsDiv.innerHTML = `
                    <div class="success-card">
                        <div class="success-icon-wrapper">
                            <span class="success-icon">‚úì</span>
                        </div>
                        <div class="success-title">Validaci√≥n exitosa</div>
                        <div class="success-message">No se encontraron motivos de rechazo en el JSON.</div>
                    </div>
                `;
            } else {
                statusBadge.textContent = `${errors.length} error${errors.length > 1 ? 'es' : ''} encontrado${errors.length > 1 ? 's' : ''}`;
                statusBadge.style.background = 'rgba(248, 113, 113, 0.2)';
                statusBadge.style.color = '#fca5a5';

                let errorsHTML = '<div class="error-list">';

                errors.forEach((error, index) => {
                    const hasSource = error.source && error.source.trim() !== '' && error.source !== 'Objeto no encontrado.' && !error.source.includes('None');

                    errorsHTML += `
                        <div class="error-card" style="animation-delay: ${index * 0.1}s">
                            <div class="error-content">
                                <div class="error-type">${error.type_error}</div>
                                <div class="error-message">${error.error}</div>
                                ${hasSource ? `
                                    <!-- <div class="error-source">${error.source}</div> -->
                                    <button class="error-navigate-btn" onclick="navigateToJsonElement('${error.source}')" type="button">
                                        Ir a elemento
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    `;
                });

                errorsHTML += '</div>';
                resultsDiv.innerHTML = errorsHTML;
            }
        }

        function displayError(message) {
            const resultsDiv = document.getElementById('resultsContent');
            const statusBadge = document.getElementById('statusBadge');

            statusBadge.textContent = 'Error al procesar';
            statusBadge.style.background = 'rgba(248, 113, 113, 0.2)';
            statusBadge.style.color = '#fca5a5';

            resultsDiv.innerHTML = `
                <div class="error-card">
                    <div class="error-icon">‚ùå</div>
                    <div class="error-content">
                        <div class="error-type">Error de formato</div>
                        <div class="error-message">${message}</div>
                    </div>
                </div>
            `;

            document.getElementById('contentWrapper').style.display = 'flex';
        }

        document.getElementById('copyBtn').addEventListener('click', () => {
            if (currentJSON) {
                const jsonString = JSON.stringify(currentJSON, null, 2);
                navigator.clipboard.writeText(jsonString).then(() => {
                    showToast('‚úì JSON copiado correctamente', 'success');
                });
            }
        });

        function showToast(message = '‚úì JSON copiado correctamente', type = 'success') {
            const toast = document.getElementById('toast');

            toast.innerHTML = `
                <div class="toast-icon">${type === 'success' ? '‚úì' : type === 'warning' ? 'X' : '‚ùå'}</div>
                ${message}
            `;

            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
    </script>
</body>

</html>
